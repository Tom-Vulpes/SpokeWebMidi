<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            background: #0a0a0f;
            color: #ffffff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .ui {
            position: fixed;
            top: 30px;
            right: 30px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-end;
        }
        
        .status {
            background: rgba(177, 156, 217, 0.15);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid rgba(177, 156, 217, 0.3);
            font-size: 0.85em;
            letter-spacing: 1px;
            color: #d9c7ff;
        }
        
        .status.active {
            background: rgba(177, 156, 217, 0.3);
            border-color: #b19cd9;
            box-shadow: 0 0 20px rgba(177, 156, 217, 0.4);
        }
        
        button {
            background: linear-gradient(135deg, #b19cd9 0%, #9b7ec9 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(177, 156, 217, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(177, 156, 217, 0.5);
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em;
            color: #b19cd9;
            text-align: center;
            z-index: 50;
        }
        
        .loading-bar {
            width: 300px;
            height: 4px;
            background: rgba(177, 156, 217, 0.2);
            border-radius: 2px;
            margin-top: 20px;
            overflow: hidden;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #b19cd9, #9b7ec9);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(177, 156, 217, 0.8);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui">
        <div class="status" id="midiStatus">MIDI: Disconnected</div>
        <div class="status" id="sampleStatus">Samples: 0 / 151</div>
        <button id="connectMidi">Connect MIDI</button>
    </div>
    
    <div class="loading" id="loading">
        <div>Loading samples...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="progress"></div>
        </div>
    </div>

    <script>
        // CONFIGURATION
        const CONFIG = {
            username: 'Tom-Vulpes',
            repo: 'SpokeWebMidi',
            branch: 'main',
            samplesFolder: 'notes',
            numberOfSamples: 150
        };
        
        function formatSampleNumber(num) {
            return `note_${String(num).padStart(3, '0')}`;
        }
        
        // Audio
        let audioContext;
        let masterGain;
        const samples = new Map();
        const activeSources = new Map();
        let midiAccess = null;
        
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        
        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Node class - shared vertices
        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.vx = (Math.random() - 0.5) * 0.8;
                this.vy = (Math.random() - 0.5) * 0.8;
            }
            
            update() {
                this.vx += (Math.random() - 0.5) * 0.15;
                this.vy += (Math.random() - 0.5) * 0.15;
                this.vx *= 0.92;
                this.vy *= 0.92;
                this.x += this.vx;
                this.y += this.vy;
                
                const dx = this.baseX - this.x;
                const dy = this.baseY - this.y;
                this.x += dx * 0.02;
                this.y += dy * 0.02;
                
                if (this.x < -50) this.x = -50;
                if (this.x > width + 50) this.x = width + 50;
                if (this.y < -50) this.y = -50;
                if (this.y > height + 50) this.y = height + 50;
            }
        }
        
        // Cell class
        class Cell {
            constructor(noteNumber, nodes) {
                this.noteNumber = noteNumber;
                this.nodes = nodes;
                
                const hue = (noteNumber / (CONFIG.numberOfSamples + 1)) * 360;
                this.hue = hue;
                this.saturation = 65;
                this.lightness = 55;
                
                this.active = false;
                this.activePulse = 0;
                this.baseAlpha = 0.25;
                this.alpha = this.baseAlpha;
            }
            
            update() {
                if (this.active) {
                    this.activePulse += 0.12;
                    this.alpha = this.baseAlpha + Math.sin(this.activePulse) * 0.6;
                    this.saturation = 65 + Math.sin(this.activePulse) * 25;
                    this.lightness = 55 + Math.sin(this.activePulse) * 25;
                    
                    if (this.activePulse > Math.PI * 2) {
                        this.active = false;
                        this.activePulse = 0;
                        this.alpha = this.baseAlpha;
                        this.saturation = 65;
                        this.lightness = 55;
                    }
                }
            }
            
            draw() {
                if (this.nodes.length < 3) return;
                
                ctx.beginPath();
                ctx.moveTo(this.nodes[0].x, this.nodes[0].y);
                for (let i = 1; i < this.nodes.length; i++) {
                    ctx.lineTo(this.nodes[i].x, this.nodes[i].y);
                }
                ctx.closePath();
                
                ctx.fillStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.alpha})`;
                ctx.fill();
                
                if (this.active) {
                    ctx.strokeStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness + 25}%, 0.9)`;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, 1)`;
                } else {
                    ctx.strokeStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness + 15}%, 0.5)`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, 0.3)`;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                const centerX = this.nodes.reduce((sum, n) => sum + n.x, 0) / this.nodes.length;
                const centerY = this.nodes.reduce((sum, n) => sum + n.y, 0) / this.nodes.length;
                
                if (this.active) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)';
                    ctx.font = 'bold 16px Georgia';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.font = '13px Georgia';
                }
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.noteNumber, centerX, centerY);
                ctx.shadowBlur = 0;
            }
            
            trigger() {
                this.active = true;
                this.activePulse = 0;
            }
            
            containsPoint(x, y) {
                let inside = false;
                for (let i = 0, j = this.nodes.length - 1; i < this.nodes.length; j = i++) {
                    const xi = this.nodes[i].x, yi = this.nodes[i].y;
                    const xj = this.nodes[j].x, yj = this.nodes[j].y;
                    
                    const intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
        }
        
        const nodes = [];
        const cells = [];
        
        function createSharedNodeNetwork() {
            const totalCells = CONFIG.numberOfSamples + 1;
            const cols = Math.ceil(Math.sqrt(totalCells * 1.3));
            const rows = Math.ceil(totalCells / cols) + 1;
            const cellWidth = width / (cols - 1);
            const cellHeight = height / (rows - 1);
            
            // Create shared node grid
            const nodeGrid = [];
            for (let row = 0; row < rows; row++) {
                nodeGrid[row] = [];
                for (let col = 0; col < cols; col++) {
                    const randomOffsetX = (Math.random() - 0.5) * cellWidth * 0.3;
                    const randomOffsetY = (Math.random() - 0.5) * cellHeight * 0.3;
                    const node = new Node(
                        col * cellWidth + randomOffsetX,
                        row * cellHeight + randomOffsetY
                    );
                    nodeGrid[row][col] = node;
                    nodes.push(node);
                }
            }
            
            // Create cells - each cell shares nodes with neighbors
            let cellIndex = 0;
            
            for (let row = 0; row < rows - 1; row++) {
                for (let col = 0; col < cols - 1; col++) {
                    if (cellIndex > CONFIG.numberOfSamples) break;
                    
                    // Each cell is made from 4 corner nodes
                    // These same nodes are used by adjacent cells
                    const cellNodes = [
                        nodeGrid[row][col],
                        nodeGrid[row][col + 1],
                        nodeGrid[row + 1][col + 1],
                        nodeGrid[row + 1][col]
                    ];
                    
                    cells.push(new Cell(cellIndex, cellNodes));
                    cellIndex++;
                }
                if (cellIndex > CONFIG.numberOfSamples) break;
            }
        }
        
        function animate() {
            ctx.fillStyle = 'rgba(10, 10, 15, 0.12)';
            ctx.fillRect(0, 0, width, height);
            
            nodes.forEach(node => node.update());
            
            cells.forEach(cell => {
                cell.update();
                cell.draw();
            });
            
            // Draw nodes
            nodes.forEach(node => {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(177, 156, 217, 0.4)';
                ctx.fill();
                
                ctx.shadowBlur = 8;
                ctx.shadowColor = 'rgba(177, 156, 217, 0.6)';
                ctx.beginPath();
                ctx.arc(node.x, node.y, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(217, 199, 255, 0.8)';
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            requestAnimationFrame(animate);
        }
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.8;
                masterGain.connect(audioContext.destination);
            }
        }
        
        function updateStatus(id, text, active = false) {
            const el = document.getElementById(id);
            el.textContent = text;
            if (active) {
                el.classList.add('active');
            } else {
                el.classList.remove('active');
            }
        }
        
        function playSample(sampleNumber, velocity = 127) {
            if (!samples.has(sampleNumber)) return;
            
            initAudio();
            
            if (activeSources.has(sampleNumber)) {
                const { source } = activeSources.get(sampleNumber);
                try {
                    source.stop();
                } catch (e) {}
                activeSources.delete(sampleNumber);
            }
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            
            source.buffer = samples.get(sampleNumber);
            gainNode.gain.value = velocity / 127;
            
            source.connect(gainNode);
            gainNode.connect(masterGain);
            source.start(0);
            
            activeSources.set(sampleNumber, { source, gainNode });
            
            const cell = cells.find(c => c.noteNumber === sampleNumber);
            if (cell) {
                cell.trigger();
            }
            
            source.onended = () => {
                if (activeSources.get(sampleNumber)?.source === source) {
                    activeSources.delete(sampleNumber);
                }
            };
        }
        
        function handleMIDIMessage(message) {
            const [status, midiNote, velocity] = message.data;
            const command = status & 0xf0;
            
            if (command === 0x90 && velocity > 0) {
                const sampleNumber = midiNote % (CONFIG.numberOfSamples + 1);
                playSample(sampleNumber, velocity);
            }
        }
        
        async function connectMIDI() {
            try {
                midiAccess = await navigator.requestMIDIAccess();
                const inputs = Array.from(midiAccess.inputs.values());
                
                if (inputs.length === 0) {
                    updateStatus('midiStatus', 'MIDI: No Devices');
                    alert('No MIDI devices found.');
                    return;
                }
                
                inputs.forEach(input => {
                    input.onmidimessage = handleMIDIMessage;
                });
                
                updateStatus('midiStatus', 'MIDI: Connected', true);
                
                midiAccess.onstatechange = (event) => {
                    if (event.port.type === 'input') {
                        const currentInputs = Array.from(midiAccess.inputs.values());
                        updateStatus('midiStatus', currentInputs.length > 0 ? 'MIDI: Connected' : 'MIDI: Disconnected', currentInputs.length > 0);
                    }
                };
            } catch (error) {
                updateStatus('midiStatus', 'MIDI: Error');
                alert('MIDI Error: ' + error.message);
            }
        }
        
        async function loadSample(sampleNumber) {
            initAudio();
            
            const formats = ['wav', 'mp3'];
            const fileName = formatSampleNumber(sampleNumber);
            
            for (const format of formats) {
                const url = `https://raw.githubusercontent.com/${CONFIG.username}/${CONFIG.repo}/${CONFIG.branch}/${CONFIG.samplesFolder}/${fileName}.${format}`;
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) continue;
                    
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    samples.set(sampleNumber, audioBuffer);
                    
                    return true;
                } catch (error) {
                    console.error(`Failed ${fileName}.${format}:`, error.message);
                }
            }
            
            return false;
        }
        
        async function autoLoadSamples() {
            const loadingDiv = document.getElementById('loading');
            const progressBar = document.getElementById('progress');
            
            let loadedCount = 0;
            const totalSamples = CONFIG.numberOfSamples + 1;
            
            for (let i = 0; i <= CONFIG.numberOfSamples; i++) {
                if (await loadSample(i)) {
                    loadedCount++;
                }
                
                const progress = (i + 1) / totalSamples * 100;
                progressBar.style.width = progress + '%';
                updateStatus('sampleStatus', `Samples: ${loadedCount} / ${totalSamples}`);
            }
            
            loadingDiv.style.display = 'none';
            
            if (loadedCount > 0) {
                updateStatus('sampleStatus', `Samples: ${loadedCount} / ${totalSamples}`, true);
            }
        }
        
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            for (let i = cells.length - 1; i >= 0; i--) {
                const cell = cells[i];
                if (cell.containsPoint(x, y)) {
                    if (samples.has(cell.noteNumber)) {
                        playSample(cell.noteNumber, 100);
                        break;
                    }
                }
            }
        });
        
        createSharedNodeNetwork();
        animate();
        autoLoadSamples();
        
        document.getElementById('connectMidi').addEventListener('click', connectMIDI);
        
        if (!navigator.requestMIDIAccess) {
            alert('Web MIDI API not supported. Please use Chrome, Edge, or Opera.');
        }
    </script>
</body>
</html>
